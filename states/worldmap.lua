local WorldMap = {}
local Sprites = require "sprites"
local Color = require("color")
local Inventory = require("inventory")
local Paperdoll = require("paperdoll")
local WorldGen = require("worldgen")
local GameClock = require("gameclock")
local Utils = require("utils")

function WorldMap:load()
    print("[WorldMap] Starting load()")
    -- Player state
    self.player = {
        x = 200,  -- start somewhere near top-left
        y = 200,
        speed = 220,
        size = 14,
        direction = "down",
    }

    -- Vehicle state
    self.vehicle = {
        x = 300,
        y = 300,
        direction = "right",
        speed = 450,          -- Much faster than walking
        highwaySpeed = 600,   -- Even faster on highways
        inVehicle = false,
        placed = false,       -- Vehicle starts not placed until player finds one
    }

    print("[WorldMap] Creating inventory")
    -- Player inventory (Diablo 2-style grid)
    self.inventory = Inventory:new()

    print("[WorldMap] Creating paperdoll")
    -- Player character paperdoll
    self.playerCharacter = Paperdoll:newCharacter({
        skinTone = "medium",
        hairStyle = "short",
        hairColor = "brown",
        shirtStyle = "tshirt",
        shirtColor = "blue",
        pantsStyle = "pants",
        pantsColor = "brown",
        shoesStyle = "sneakers",
        shoesColor = "black"
    })

    print("[WorldMap] Adding starting items")
    -- Give player some starting items
    self.inventory:addItem("rusty_sword", 1)
    self.inventory:addItem("cloth_shirt", 1)
    self.inventory:addItem("leather_boots", 1)
    self.inventory:addItem("health_potion", 3)

    print("[WorldMap] Initializing game clock")
    -- Initialize game clock
    GameClock:init(8, 0, 1)

    -- World and tiles (will be generated or loaded)
    -- Size comes from WorldGen CONFIG
    self.world = {
        tileSize = WorldGen.CONFIG.tileSize,
        cols = WorldGen.CONFIG.worldCols,
        rows = WorldGen.CONFIG.worldRows,
        width = 0,
        height = 0,
    }
    self.world.width = self.world.cols * self.world.tileSize
    self.world.height = self.world.rows * self.world.tileSize

    -- Tiles will be generated by WorldGen or loaded from save
    self.tiles = {}

    -- Points of Interest (towns, dungeons, etc.)
    self.pointsOfInterest = {}

    -- Town data for the world
    self.towns = {}

    -- Message system
    self.messageSystem = {
        currentMessage = nil,
        messageTimer = 0,
        messageDuration = 4.0, -- seconds
        fadeInTime = 0.5,
        fadeOutTime = 0.5
    }

    -- Camera
    self.camera = { x = 0, y = 0 }

    -- HUD
    self.hud = {
        name = "",
        level = 1,
        playTime = 0,
    }

    -- Nearby POI for interaction
    self.nearbyPOI = nil
    self.interactionPrompt = nil

    print("[WorldMap] Initializing sprites")
    -- Initialize sprites
    Sprites:init()
    print("[WorldMap] load() completed")
end

function WorldMap:enter()
    print("[WorldMap] Starting enter()")
    -- Set controls panel mode
    if ControlsPanel then ControlsPanel:setMode("worldmap") end

    if self.saveData then
        self.hud.name = self.saveData.characterName or ""
        self.hud.level = self.saveData.level or 1
        self.hud.playTime = self.saveData.playTime or 0
    end

    if self.worldData then
        print("[WorldMap] Loading existing world data")
        -- Load existing world data
        self:loadWorldFromData()
        print("[WorldMap] World data loaded")

        -- Load player position if available
        if self.saveData and self.saveData.playerX and self.saveData.playerY then
            self.player.x = self.saveData.playerX
            self.player.y = self.saveData.playerY
        elseif self.worldData.playerStartX and self.worldData.playerStartY then
            self.player.x = self.worldData.playerStartX
            self.player.y = self.worldData.playerStartY
        end
    else
        print("[WorldMap] Generating new world")
        -- New game - generate fresh world
        self:generateNewWorld()
        print("[WorldMap] New world generated")
    end

    print("[WorldMap] Resuming game clock")
    -- Resume game clock
    GameClock:resume()
    print("[WorldMap] enter() completed")
end

function WorldMap:loadWorldFromData()
    print("[WorldMap] Starting loadWorldFromData()")
    if not self.worldData then return end

    print("[WorldMap] Loading game clock state")
    -- Load game clock state if available
    if self.worldData.gameClock then
        GameClock:deserialize(self.worldData.gameClock)
    end

    print("[WorldMap] Regenerating world from seed")
    -- Regenerate world from seed (tiles are too large to save)
    if self.worldData.seed then
        local seed = self.worldData.seed
        self.world.cols = self.worldData.cols or 200
        self.world.rows = self.worldData.rows or 150
        self.world.tileSize = self.worldData.tileSize or 32
        self.world.width = self.world.cols * self.world.tileSize
        self.world.height = self.world.rows * self.world.tileSize

        print("[WorldMap] Calling WorldGen:generate with cols=" .. self.world.cols .. ", rows=" .. self.world.rows)
        -- Generate world using WorldGen with the saved seed
        local worldData = WorldGen:generate(seed, self.world.cols, self.world.rows)
        print("[WorldMap] WorldGen:generate completed")

        -- Copy generated data
        self.tiles = worldData.tiles
        self.towns = worldData.towns

        -- Convert towns to POIs
        self.pointsOfInterest = {}
        for i, town in ipairs(self.towns) do
            -- Restore saved states if available
            local discovered = false
            local visited = false
            if self.worldData.townStates and self.worldData.townStates[i] then
                discovered = self.worldData.townStates[i].discovered or false
                visited = self.worldData.townStates[i].visited or false
            end

            table.insert(self.pointsOfInterest, {
                x = town.x or town.worldX,
                y = town.y or town.worldY,
                radius = town.radius or 20,
                name = town.name,
                message = town.message or ("A " .. town.size .. " town awaits. Population: " .. #town.npcs),
                discovered = discovered,
                color = town.color or {0.8, 0.6, 0.3},
                levelType = "town",
                levelSeed = town.seed,
                visited = visited,
                townData = town
            })
        end

        -- Add other POIs (dungeons, caves, etc)
        for i, poi in ipairs(worldData.pointsOfInterest) do
            -- Restore saved states if available
            local discovered = false
            local visited = false
            if self.worldData.poiStates then
                for _, savedPoi in ipairs(self.worldData.poiStates) do
                    if savedPoi.name == poi.name then
                        discovered = savedPoi.discovered or false
                        visited = savedPoi.visited or false
                        break
                    end
                end
            end

            -- Home base is always discovered
            if poi.isHomeBase or poi.levelType == "homebase" then
                discovered = true
            end

            table.insert(self.pointsOfInterest, {
                x = poi.x,  -- Already in pixel coordinates from worldgen
                y = poi.y,  -- Already in pixel coordinates from worldgen
                radius = poi.radius or 18,
                name = poi.name,
                message = poi.message,
                discovered = discovered,
                color = poi.color,
                levelType = poi.levelType,  -- Use levelType, not type
                levelSeed = poi.levelSeed or math.random(10000, 99999),
                visited = visited,
                isHomeBase = poi.isHomeBase or (poi.levelType == "homebase")
            })
        end

        -- Store seed for saving
        self.worldData.seed = seed
    else
        -- No seed available - generate fresh world
        self:generateNewWorld()
    end

    print("Loaded " .. #self.pointsOfInterest .. " points of interest")
    print("Loaded " .. #self.towns .. " towns")

    -- Place vehicle if not already placed (for saves from before vehicle was added)
    if not self.vehicle.placed then
        local startX = self.worldData.playerStartX or 200
        local startY = self.worldData.playerStartY or 200
        print("[WorldMap] Placing vehicle")
        self:placeVehicle(startX, startY)
        print("[WorldMap] Vehicle placed")
    end
    print("[WorldMap] loadWorldFromData() completed")
end

function WorldMap:generateNewWorld()
    local seed = self.worldData and self.worldData.seed or os.time()

    -- Generate world using WorldGen
    local worldData = WorldGen:generate(seed, self.world.cols, self.world.rows)

    -- Copy generated data
    self.tiles = worldData.tiles
    self.towns = worldData.towns

    -- Convert towns to POIs
    self.pointsOfInterest = {}
    for _, town in ipairs(self.towns) do
        table.insert(self.pointsOfInterest, {
            x = town.x or town.worldX,
            y = town.y or town.worldY,
            radius = town.radius or 20,
            name = town.name,
            message = town.message or ("A " .. town.size .. " town awaits. Population: " .. #town.npcs),
            discovered = false,
            color = town.color or {0.8, 0.6, 0.3},
            levelType = "town",
            levelSeed = town.seed,
            visited = false,
            townData = town
        })
    end

    -- Add other POIs (dungeons, caves, etc)
    for _, poi in ipairs(worldData.pointsOfInterest) do
        table.insert(self.pointsOfInterest, {
            x = poi.x,  -- Already in pixel coordinates from worldgen
            y = poi.y,  -- Already in pixel coordinates from worldgen
            radius = poi.radius or 18,
            name = poi.name,
            message = poi.message,
            discovered = false,
            color = poi.color,
            levelType = poi.levelType,  -- Use levelType, not type
            levelSeed = poi.levelSeed or math.random(10000, 99999),
            visited = false
        })
    end

    -- Find a valid starting position (on land, preferably near a town)
    local startX, startY = self:findStartPosition()
    self.player.x = startX
    self.player.y = startY

    -- Place vehicle near starting position (find a highway tile if possible)
    self:placeVehicle(startX, startY)

    -- Store seed for saving
    if not self.worldData then
        self.worldData = {}
    end
    self.worldData.seed = seed
    self.worldData.cols = self.world.cols
    self.worldData.rows = self.world.rows
    self.worldData.tileSize = self.world.tileSize
end

function WorldMap:findStartPosition()
    -- Try to start near the first town
    if #self.towns > 0 then
        local town = self.towns[1]
        return town.worldX + 50, town.worldY + 50
    end

    -- Otherwise find any land tile
    local ts = self.world.tileSize
    for row = 1, self.world.rows do
        for col = 1, self.world.cols do
            local tile = self.tiles[row][col]
            if tile == "grass" or tile == "sand" or tile == "forest" then
                return col * ts, row * ts
            end
        end
    end

    -- Fallback
    return 200, 200
end

function WorldMap:placeVehicle(nearX, nearY)
    -- Try to find a highway tile near the given position
    local ts = self.world.tileSize
    local searchRadius = 10  -- tiles to search

    local centerCol = math.floor(nearX / ts)
    local centerRow = math.floor(nearY / ts)

    -- Spiral outward to find nearest highway
    for radius = 1, searchRadius do
        for dy = -radius, radius do
            for dx = -radius, radius do
                if math.abs(dx) == radius or math.abs(dy) == radius then
                    local col = centerCol + dx
                    local row = centerRow + dy
                    if col >= 1 and col <= self.world.cols and row >= 1 and row <= self.world.rows then
                        local tile = self.tiles[row] and self.tiles[row][col]
                        if tile == "highway_h" or tile == "highway_v" or tile == "highway" then
                            self.vehicle.x = col * ts + ts / 2
                            self.vehicle.y = row * ts + ts / 2
                            self.vehicle.placed = true
                            self.vehicle.direction = tile == "highway_v" and "down" or "right"
                            return
                        end
                    end
                end
            end
        end
    end

    -- No highway found, place on any traversable tile nearby
    for radius = 1, searchRadius do
        for dy = -radius, radius do
            for dx = -radius, radius do
                if math.abs(dx) == radius or math.abs(dy) == radius then
                    local col = centerCol + dx
                    local row = centerRow + dy
                    if col >= 1 and col <= self.world.cols and row >= 1 and row <= self.world.rows then
                        local tile = self.tiles[row] and self.tiles[row][col]
                        if tile == "grass" or tile == "sand" then
                            self.vehicle.x = col * ts + ts / 2
                            self.vehicle.y = row * ts + ts / 2
                            self.vehicle.placed = true
                            self.vehicle.direction = "right"
                            return
                        end
                    end
                end
            end
        end
    end

    -- Fallback - place near player
    self.vehicle.x = nearX + 60
    self.vehicle.y = nearY
    self.vehicle.placed = true
    self.vehicle.direction = "right"
end

-- Helper function alias from Utils module
local clamp = Utils.clamp

function WorldMap:update(dt)
    -- Update game clock
    GameClock:update(dt)

    local moveX, moveY = 0, 0
    if love.keyboard.isDown("left") or love.keyboard.isDown("a") then
        moveX = moveX - 1
    end
    if love.keyboard.isDown("right") or love.keyboard.isDown("d") then
        moveX = moveX + 1
    end
    if love.keyboard.isDown("up") or love.keyboard.isDown("w") then
        moveY = moveY - 1
    end
    if love.keyboard.isDown("down") or love.keyboard.isDown("s") then
        moveY = moveY + 1
    end

    if moveX ~= 0 or moveY ~= 0 then
        local length = math.sqrt(moveX * moveX + moveY * moveY)
        moveX, moveY = moveX / length, moveY / length

        -- Update direction for car sprite
        if math.abs(moveX) > math.abs(moveY) then
            self.player.direction = moveX > 0 and "right" or "left"
        else
            self.player.direction = moveY > 0 and "down" or "up"
        end

        -- Determine speed based on vehicle state and terrain
        local speed = self.player.speed
        if self.vehicle.inVehicle then
            -- Check if on highway for extra speed
            local tileCol = math.floor(self.player.x / self.world.tileSize) + 1
            local tileRow = math.floor(self.player.y / self.world.tileSize) + 1
            tileCol = clamp(tileCol, 1, self.world.cols)
            tileRow = clamp(tileRow, 1, self.world.rows)
            local tile = self.tiles[tileRow] and self.tiles[tileRow][tileCol]

            if tile == "highway_h" or tile == "highway_v" or tile == "highway" then
                speed = self.vehicle.highwaySpeed
            else
                speed = self.vehicle.speed
            end

            -- Update vehicle direction
            self.vehicle.direction = self.player.direction
        end

        self.player.x = self.player.x + moveX * speed * dt
        self.player.y = self.player.y + moveY * speed * dt
    end

    local half = self.player.size / 2
    self.player.x = clamp(self.player.x, half, self.world.width - half)
    self.player.y = clamp(self.player.y, half, self.world.height - half)

    -- Keep vehicle position synced when driving
    if self.vehicle.inVehicle then
        self.vehicle.x = self.player.x
        self.vehicle.y = self.player.y
    end

    -- Check for collisions with points of interest
    self:checkPointOfInterestCollisions()

    -- Check for vehicle proximity (only when not in vehicle)
    if self.vehicle.placed and not self.vehicle.inVehicle then
        local distance = math.sqrt((self.player.x - self.vehicle.x)^2 + (self.player.y - self.vehicle.y)^2)
        if distance < 50 and not self.nearbyPOI then
            self.interactionPrompt = "Press E to enter car"
        end
    end

    -- Update message system
    if self.messageSystem.currentMessage then
        self.messageSystem.messageTimer = self.messageSystem.messageTimer + dt
        if self.messageSystem.messageTimer >= self.messageSystem.messageDuration then
            self.messageSystem.currentMessage = nil
            self.messageSystem.messageTimer = 0
        end
    end

    -- Camera follows player, clamped to world bounds
    local screenW, screenH = love.graphics.getDimensions()
    self.camera.x = clamp(self.player.x - screenW / 2, 0, self.world.width - screenW)
    self.camera.y = clamp(self.player.y - screenH / 2, 0, self.world.height - screenH)
end

function WorldMap:checkPointOfInterestCollisions()
    self.nearbyPOI = nil
    self.interactionPrompt = nil

    for _, poi in ipairs(self.pointsOfInterest) do
        local distance = math.sqrt((self.player.x - poi.x)^2 + (self.player.y - poi.y)^2)
        local collisionDistance = self.player.size + poi.radius

        if distance <= collisionDistance and not poi.discovered then
            poi.discovered = true
            self:showMessage(poi.name, poi.message)
        end

        -- Track nearby POI for interaction
        if distance <= collisionDistance then
            self.nearbyPOI = poi
            self.interactionPrompt = "Press SPACE to enter " .. poi.name
        end
    end
end

function WorldMap:enterTown(poi)
    local town = require "states.town"
    local newState = {}
    for k, v in pairs(town) do newState[k] = v end
    newState.saveDir = self.saveDir
    newState.saveData = self.saveData
    newState.worldData = self.worldData
    -- Pass specific town data from POI if available
    newState.townData = poi and poi.townData or self.townData
    newState.optionsData = self.optionsData
    newState.gameClock = GameClock  -- Pass game clock for NPC schedules
    newState.playerCharacter = self.playerCharacter  -- Pass paperdoll for player drawing
    Gamestate:push(newState)
end

function WorldMap:enterLevel(poi)
    local stateModule
    -- Use Contra-style shooter for the portal
    if poi.levelType == "portal" then
        stateModule = require "states.contra"
    -- Use base building for home base and exploration areas
    elseif poi.levelType == "homebase" or poi.levelType == "ruins" or
           poi.levelType == "cave" or poi.levelType == "forest" or
           poi.levelType == "oasis" then
        stateModule = require "states.basebuilding"
    else
        stateModule = require "states.level"
    end

    local newState = {}
    for k, v in pairs(stateModule) do newState[k] = v end
    newState.saveDir = self.saveDir
    newState.saveData = self.saveData
    newState.worldData = self.worldData
    newState.townData = self.townData
    newState.optionsData = self.optionsData
    newState.poiData = poi
    -- Mark as home base for save/load functionality
    newState.isHomeBase = (poi.levelType == "homebase")
    Gamestate:push(newState)
end

function WorldMap:showMessage(title, message)
    self.messageSystem.currentMessage = {
        title = title,
        message = message
    }
    self.messageSystem.messageTimer = 0
end

function WorldMap:draw()
    local screenW, screenH = love.graphics.getDimensions()
    local ts = self.world.tileSize

    love.graphics.push()
    -- Round camera position to prevent sub-pixel jittering
    love.graphics.translate(-math.floor(self.camera.x + 0.5), -math.floor(self.camera.y + 0.5))

    -- Draw visible tiles only using sprites
    local startCol = math.max(1, math.floor(self.camera.x / ts) + 1)
    local endCol = math.min(self.world.cols, math.floor((self.camera.x + screenW) / ts) + 1)
    local startRow = math.max(1, math.floor(self.camera.y / ts) + 1)
    local endRow = math.min(self.world.rows, math.floor((self.camera.y + screenH) / ts) + 1)

    Color.set(1, 1, 1, 1)
    for row = startRow, endRow do
        for col = startCol, endCol do
            local tile = self.tiles[row][col]
            local sprite = Sprites:getTile(tile, col, row)
            if sprite then
                love.graphics.draw(sprite, (col - 1) * ts, (row - 1) * ts, 0, Sprites.scale, Sprites.scale)
            end
        end
    end

    -- Draw Points of Interest using sprite markers
    for _, poi in ipairs(self.pointsOfInterest) do
        -- Check if POI is visible on screen
        if poi.x >= self.camera.x - poi.radius and poi.x <= self.camera.x + screenW + poi.radius and
           poi.y >= self.camera.y - poi.radius and poi.y <= self.camera.y + screenH + poi.radius then

            -- Get POI marker sprite
            local markerSprite = Sprites:getPOIMarker(poi.levelType)

            -- Draw with pulsing effect
            local pulse = math.sin(love.timer.getTime() * 3) * 0.15 + 0.85
            local markerScale = (poi.radius / 8) * pulse * 1.5  -- Larger markers

            Color.set(1, 1, 1, 1)
            if markerSprite then
                love.graphics.draw(markerSprite,
                    poi.x, poi.y,
                    0,
                    markerScale, markerScale,
                    8, 8)  -- Center origin
            else
                -- Fallback to larger, more visible circle with outline
                Color.set(poi.color[1] * pulse, poi.color[2] * pulse, poi.color[3] * pulse, 0.9)
                love.graphics.circle("fill", poi.x, poi.y, poi.radius * 1.2)
                Color.set(1, 1, 1, 0.8)
                love.graphics.setLineWidth(2)
                love.graphics.circle("line", poi.x, poi.y, poi.radius * 1.2)
            end

            -- Draw name if discovered
            if poi.discovered then
                Color.set(1, 1, 1, 0.9)
                love.graphics.print(poi.name, poi.x - love.graphics.getFont():getWidth(poi.name) / 2, poi.y - poi.radius - 25)
            end
        end
    end

    -- Draw parked vehicle if player is not in it
    if self.vehicle.placed and not self.vehicle.inVehicle then
        Color.set(1, 1, 1, 1)
        local carSprite = Sprites:getCarSprite(self.vehicle.direction)
        if carSprite then
            local carScale = 2.5
            love.graphics.draw(carSprite,
                self.vehicle.x, self.vehicle.y,
                0,
                carScale, carScale,
                8, 8)  -- Center origin
        end
    end

    -- Player or vehicle sprite
    Color.set(1, 1, 1, 1)
    if self.vehicle.inVehicle then
        -- Draw car when driving
        local carSprite = Sprites:getCarSprite(self.vehicle.direction)
        if carSprite then
            local carScale = 2.5
            love.graphics.draw(carSprite,
                self.player.x, self.player.y,
                0,
                carScale, carScale,
                8, 8)  -- Center origin
        end
    else
        -- Draw player character
        local playerSprite = Sprites.images.player
        if playerSprite then
            local playerScale = self.player.size / 6
            love.graphics.draw(playerSprite,
                self.player.x, self.player.y,
                0,
                playerScale, playerScale,
                8, 8)  -- Center origin
        else
            -- Fallback to circle
            love.graphics.circle("fill", self.player.x, self.player.y, self.player.size)
            Color.set(0.1, 0.1, 0.2)
            love.graphics.setLineWidth(2)
            love.graphics.circle("line", self.player.x, self.player.y, self.player.size)
        end
    end

    love.graphics.pop()

    -- Day/night ambient overlay
    local ambient = GameClock:getInterpolatedAmbient()
    if ambient[1] < 1 or ambient[2] < 1 or ambient[3] < 1 then
        -- Calculate darkness overlay
        local darkness = 1 - math.min(ambient[1], ambient[2], ambient[3])
        if darkness > 0.1 then
            -- Blue-tinted darkness for night
            local r = 0.05 * (1 - ambient[1])
            local g = 0.05 * (1 - ambient[2])
            local b = 0.15 * (1 - ambient[3])
            Color.set(r, g, b, darkness * 0.6)
            love.graphics.rectangle("fill", 0, 0, screenW, screenH)
        end
    end

    -- Enhanced HUD
    self:drawHUD()

    -- Draw interaction prompt
    if self.interactionPrompt then
        self:drawInteractionPrompt()
    end

    -- Draw message overlay
    if self.messageSystem.currentMessage then
        self:drawMessageOverlay()
    end
end

function WorldMap:drawHUD()
    local screenW = love.graphics.getDimensions()

    -- HUD background panel
    Color.set(0.05, 0.08, 0.12, 0.9)
    love.graphics.rectangle("fill", 5, 5, 500, 70, 6, 6)

    -- Panel border
    Color.set(0.30, 0.45, 0.55)
    love.graphics.setLineWidth(2)
    love.graphics.rectangle("line", 5, 5, 500, 70, 6, 6)

    -- Inner highlight
    Color.set(0.40, 0.55, 0.65, 0.3)
    love.graphics.rectangle("line", 7, 7, 496, 66, 5, 5)

    -- World map title with globe icon hint
    Color.set(0.55, 0.75, 0.90)
    love.graphics.print("WORLD MAP", 15, 12)

    -- Separator
    Color.set(0.30, 0.45, 0.55)
    love.graphics.rectangle("fill", 105, 10, 2, 20)

    -- Player name and level
    Color.set(0.65, 0.95, 0.75)
    love.graphics.print(self.hud.name, 120, 12)
    Color.set(0.95, 0.85, 0.55)
    love.graphics.print("Lv." .. self.hud.level, 240, 12)

    -- Separator
    Color.set(0.30, 0.45, 0.55)
    love.graphics.rectangle("fill", 290, 10, 2, 20)

    -- Game clock display
    local periodName = GameClock:getPeriod()
    local timeStr = GameClock:getTimeString()
    local dayStr = "Day " .. GameClock:getDay()

    -- Time-based color for period
    local periodColors = {
        Night = {0.4, 0.4, 0.7},
        Dawn = {0.9, 0.7, 0.5},
        Morning = {1.0, 0.95, 0.7},
        Afternoon = {1.0, 1.0, 0.9},
        Evening = {0.95, 0.75, 0.5},
        Dusk = {0.7, 0.5, 0.7}
    }
    local periodColor = periodColors[periodName] or {0.8, 0.8, 0.8}

    Color.set(periodColor[1], periodColor[2], periodColor[3])
    love.graphics.print(timeStr, 305, 12)
    Color.set(0.6, 0.7, 0.8)
    love.graphics.print(dayStr, 390, 12)

    -- POI progress bar
    local discoveredCount = 0
    for _, poi in ipairs(self.pointsOfInterest) do
        if poi.discovered then
            discoveredCount = discoveredCount + 1
        end
    end

    -- POI label
    Color.set(0.55, 0.75, 0.90)
    love.graphics.print("Discovered:", 15, 38)

    -- Progress bar background
    local barX, barY, barW, barH = 100, 40, 120, 12
    Color.set(0.15, 0.20, 0.25)
    love.graphics.rectangle("fill", barX, barY, barW, barH, 3, 3)

    -- Progress bar fill
    local progress = #self.pointsOfInterest > 0 and (discoveredCount / #self.pointsOfInterest) or 0
    local fillColor = progress >= 1 and {0.55, 0.90, 0.55} or {0.45, 0.70, 0.90}
    Color.set(fillColor[1], fillColor[2], fillColor[3])
    love.graphics.rectangle("fill", barX + 2, barY + 2, (barW - 4) * progress, barH - 4, 2, 2)

    -- Progress bar highlight
    Color.set(fillColor[1] + 0.2, fillColor[2] + 0.2, fillColor[3] + 0.2, 0.5)
    love.graphics.rectangle("fill", barX + 2, barY + 2, (barW - 4) * progress, (barH - 4) / 2, 2, 2)

    -- POI count
    Color.set(1, 1, 1)
    love.graphics.print(string.format("%d/%d", discoveredCount, #self.pointsOfInterest), 230, 38)

    -- Controls hint (context-sensitive)
    Color.set(0.45, 0.55, 0.65)
    local controlsHint
    if self.vehicle.inVehicle then
        controlsHint = "WASD: Drive  |  E: Exit Car  |  ESC: Menu"
    elseif self.vehicle.placed then
        local distance = math.sqrt((self.player.x - self.vehicle.x)^2 + (self.player.y - self.vehicle.y)^2)
        if distance < 50 then
            controlsHint = "WASD: Move  |  E: Enter Car  |  SPACE: Enter  |  I: Inventory"
        else
            controlsHint = "WASD: Move  |  SPACE: Enter  |  I: Inventory  |  ESC: Menu"
        end
    else
        controlsHint = "WASD: Move  |  SPACE: Enter  |  I: Inventory  |  ESC: Menu"
    end
    love.graphics.print(controlsHint, 15, 55)
end

function WorldMap:drawInteractionPrompt()
    local screenW, screenH = love.graphics.getDimensions()
    local prompt = self.interactionPrompt
    local font = love.graphics.getFont()
    local textWidth = font:getWidth(prompt)

    local boxW = textWidth + 30
    local boxH = 32
    local boxX = (screenW - boxW) / 2
    local boxY = screenH - 80

    -- Pulsing effect
    local pulse = math.sin(love.timer.getTime() * 4) * 0.15 + 0.85

    -- Background
    Color.set(0.08, 0.12, 0.18, 0.9 * pulse)
    love.graphics.rectangle("fill", boxX, boxY, boxW, boxH, 8, 8)

    -- Border with glow
    Color.set(0.55, 0.85, 0.65, pulse)
    love.graphics.setLineWidth(2)
    love.graphics.rectangle("line", boxX, boxY, boxW, boxH, 8, 8)

    -- Text
    Color.set(0.85, 1, 0.90, pulse)
    love.graphics.print(prompt, boxX + 15, boxY + 8)
end

function WorldMap:drawMessageOverlay()
    local screenW, screenH = love.graphics.getDimensions()
    local msg = self.messageSystem.currentMessage
    local timer = self.messageSystem.messageTimer
    local duration = self.messageSystem.messageDuration
    local fadeIn = self.messageSystem.fadeInTime
    local fadeOut = self.messageSystem.fadeOutTime

    -- Calculate alpha based on fade in/out
    local alpha = 1.0
    if timer < fadeIn then
        alpha = timer / fadeIn
    elseif timer > duration - fadeOut then
        alpha = (duration - timer) / fadeOut
    end

    -- Small notification box in top-right corner
    local boxWidth = 280
    local boxHeight = 50
    local boxX = screenW - boxWidth - 15
    local boxY = 80

    -- Shadow
    Color.set(0, 0, 0, 0.5 * alpha)
    love.graphics.rectangle("fill", boxX + 3, boxY + 3, boxWidth, boxHeight, 6, 6)

    -- Background
    Color.set(0.08, 0.12, 0.18, 0.92 * alpha)
    love.graphics.rectangle("fill", boxX, boxY, boxWidth, boxHeight, 6, 6)

    -- Border
    Color.set(0.45, 0.60, 0.75, 0.8 * alpha)
    love.graphics.setLineWidth(2)
    love.graphics.rectangle("line", boxX, boxY, boxWidth, boxHeight, 6, 6)

    -- Small icon/indicator
    local iconX = boxX + 12
    local iconY = boxY + boxHeight / 2
    Color.set(0.85, 0.75, 0.45, alpha)
    love.graphics.circle("fill", iconX, iconY, 4)

    -- Title text (compact)
    Color.set(0.95, 0.90, 0.70, alpha)
    love.graphics.print(msg.title, boxX + 25, boxY + 10)

    -- Message text (smaller, truncated if needed)
    Color.set(0.75, 0.78, 0.82, 0.9 * alpha)
    local font = love.graphics.getFont()
    local messageText = msg.message
    -- Truncate if too long
    if font:getWidth(messageText) > boxWidth - 30 then
        while font:getWidth(messageText .. "...") > boxWidth - 30 and #messageText > 0 do
            messageText = messageText:sub(1, -2)
        end
        messageText = messageText .. "..."
    end
    love.graphics.print(messageText, boxX + 25, boxY + 28)
end

function WorldMap:keypressed(key)
    if key == "escape" then
        Gamestate:push(require("states.pause"))
    elseif key == "i" then
        -- Open inventory screen
        local inventoryScreen = require("states.inventoryscreen")
        inventoryScreen:enter(self.inventory, self.playerCharacter)
        Gamestate:push(inventoryScreen)
    elseif key == "f5" then
        self:saveGame()
    elseif key == "e" then
        -- Enter/exit vehicle
        if self.vehicle.inVehicle then
            -- Exit vehicle
            self.vehicle.inVehicle = false
            self:showMessage("Vehicle", "You exit the car.")
        elseif self.vehicle.placed then
            -- Check if near vehicle to enter
            local distance = math.sqrt((self.player.x - self.vehicle.x)^2 + (self.player.y - self.vehicle.y)^2)
            if distance < 50 then
                self.vehicle.inVehicle = true
                self.vehicle.direction = self.player.direction
                self:showMessage("Vehicle", "You get in the car. Highways give extra speed!")
            end
        end
    elseif key == "space" then
        -- Enter nearby POI (must exit vehicle first)
        if self.nearbyPOI then
            if self.vehicle.inVehicle then
                self:showMessage("Vehicle", "Exit the car first! (Press E)")
            else
                if self.nearbyPOI.levelType == "town" then
                    self:enterTown(self.nearbyPOI)
                else
                    self:enterLevel(self.nearbyPOI)
                end
            end
        end
    end
end

function WorldMap:saveGame()
    if not self.saveDir then
        print("No save directory set")
        return
    end

    -- Update stats data
    local discoveredCount = 0
    for _, poi in ipairs(self.pointsOfInterest) do
        if poi.discovered then
            discoveredCount = discoveredCount + 1
        end
    end

    local statsData = {
        characterName = self.hud.name,
        createdAt = self.saveData and self.saveData.createdAt or os.time(),
        lastPlayed = os.time(),
        playTime = self.hud.playTime,
        level = self.hud.level,
        experience = self.saveData and self.saveData.experience or 0,
        pointsOfInterest = discoveredCount,
        totalSaves = (self.saveData and self.saveData.totalSaves or 0) + 1,
        playerX = self.player.x,
        playerY = self.player.y
    }

    -- Update world data - save seed for regeneration, plus town discovery states
    local worldData = {
        seed = self.worldData.seed,
        tileSize = self.world.tileSize,
        cols = self.world.cols,
        rows = self.world.rows,
        playerStartX = self.player.x,
        playerStartY = self.player.y,
        gameClock = GameClock:serialize(),
        -- Save town discovery/visited states
        townStates = {},
        poiStates = {}
    }

    -- Save town states (don't save full town data, just states)
    for i, town in ipairs(self.towns) do
        worldData.townStates[i] = {
            discovered = false,
            visited = false
        }
        -- Check if there's a corresponding POI
        for _, poi in ipairs(self.pointsOfInterest) do
            if poi.townData and poi.townData.name == town.name then
                worldData.townStates[i].discovered = poi.discovered
                worldData.townStates[i].visited = poi.visited
                break
            end
        end
    end

    -- Save non-town POI states
    for _, poi in ipairs(self.pointsOfInterest) do
        if poi.levelType ~= "town" then
            table.insert(worldData.poiStates, {
                name = poi.name,
                discovered = poi.discovered,
                visited = poi.visited
            })
        end
    end

    -- Save all files
    local statsSuccess = love.filesystem.write(self.saveDir .. "/stats.lua", self:serializeSaveData(statsData))
    local worldSuccess = love.filesystem.write(self.saveDir .. "/world.lua", self:serializeSaveData(worldData))

    if statsSuccess and worldSuccess then
        print("Game saved to: " .. self.saveDir)
        -- Update local data
        self.saveData = statsData
    else
        print("Failed to save game")
    end
end

function WorldMap:serializeData(data, indent)
    indent = indent or ""
    local result = "{\n"
    local nextIndent = indent .. "  "

    for key, value in pairs(data) do
        local keyStr
        if type(key) == "number" then
            keyStr = ""  -- Array index, no key needed
        else
            keyStr = key .. " = "
        end

        if type(value) == "string" then
            result = result .. nextIndent .. keyStr .. "\"" .. value .. "\",\n"
        elseif type(value) == "boolean" then
            result = result .. nextIndent .. keyStr .. tostring(value) .. ",\n"
        elseif type(value) == "table" then
            result = result .. nextIndent .. keyStr .. self:serializeData(value, nextIndent) .. ",\n"
        else
            result = result .. nextIndent .. keyStr .. tostring(value) .. ",\n"
        end
    end

    result = result .. indent .. "}"
    return result
end

function WorldMap:serializeSaveData(data)
    return "return " .. self:serializeData(data) .. "\n"
end

return WorldMap


